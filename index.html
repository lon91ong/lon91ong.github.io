<!DOCTYPE html>
<!-- saved from url=(0098)http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/ -->
<html lang="en-US"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>LU Matrix Decomposition in parallel with CUDA | Noctua</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="http://blog-noctua.rhcloud.com/xmlrpc.php">
<link rel="alternate" type="application/rss+xml" title="Noctua » Feed" href="http://blog-noctua.rhcloud.com/index.php/feed/">
<link rel="alternate" type="application/rss+xml" title="Noctua » Comments Feed" href="http://blog-noctua.rhcloud.com/index.php/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="Noctua » LU Matrix Decomposition in parallel with CUDA Comments Feed" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/feed/">
<link rel="stylesheet" id="coraline-css" href="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/style.css" type="text/css" media="all">
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/jwplayer.js"></script>
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/swfobject.js"></script>
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/swfobject(1).js"></script>
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/d3.3.5.5.min.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://blog-noctua.rhcloud.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://blog-noctua.rhcloud.com/wp-includes/wlwmanifest.xml"> 
<link rel="next" title="Linux memo" href="http://blog-noctua.rhcloud.com/index.php/2011/05/31/linux-memo/">
<meta name="generator" content="WordPress 4.1.10">
<link rel="canonical" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/">
<link rel="shortlink" href="http://blog-noctua.rhcloud.com/?p=125">

<!-- Start Of Script Generated By cforms v8.7 [Oliver Seidel | www.deliciousdays.com] -->
<link rel="stylesheet" type="text/css" href="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/cforms.css">
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/cforms.js"></script>
<!-- End Of Script Generated By cforms -->

	<link href="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/SyntaxHighlighter.css" type="text/css" rel="stylesheet">
	<!-- Vipers Video Quicktags v6.3.0 | http://www.viper007bond.com/wordpress-plugins/vipers-video-quicktags/ -->
<style type="text/css">
.vvqbox { display: block; max-width: 100%; visibility: visible !important; margin: 10px auto; } .vvqbox img { max-width: 100%; height: 100%; } .vvqbox object { max-width: 100%; } 
</style>
<script type="text/javascript">
// <![CDATA[
	var vvqflashvars = {};
	var vvqparams = { wmode: "opaque", allowfullscreen: "true", allowscriptaccess: "always" };
	var vvqattributes = {};
	var vvqexpressinstall = "http://blog-noctua.rhcloud.com/wp-content/plugins/vipers-video-quicktags/resources/expressinstall.swf";
// ]]>
</script>
</head>

<body class="single single-post postid-125 single-format-standard two-column content-sidebar">
<div id="container" class="hfeed contain">
	<div id="header">
		<div id="masthead" role="banner">
						<div id="site-title">
				<span>
					<a href="http://blog-noctua.rhcloud.com/" title="Noctua" rel="home">Noctua</a>
				</span>
			</div>
			<div id="site-description">CG Tools</div>
		</div><!-- #masthead -->

		<div id="access" role="navigation">
		  			<div class="skip-link screen-reader-text"><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#content" title="Skip to content">Skip to content</a></div>
						<div class="menu"><ul><li><a href="http://blog-noctua.rhcloud.com/">Home</a></li><li class="page_item page-item-2"><a href="http://blog-noctua.rhcloud.com/index.php/about/">About</a></li><li class="page_item page-item-92"><a href="http://blog-noctua.rhcloud.com/index.php/contact/">Contact</a></li><li class="page_item page-item-341"><a href="http://blog-noctua.rhcloud.com/index.php/resume/">Resume</a></li></ul></div>
		</div><!-- #access -->

		<div id="branding">
						<a href="http://blog-noctua.rhcloud.com/">
									<img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/header_11.jpg" width="770" height="140" alt="">
							</a>
					</div><!-- #branding -->
	</div><!-- #header -->

	<div id="content-box">

<div id="content-container">
	<div id="content" role="main">
		<div id="post-125" class="post-125 post type-post status-publish format-standard hentry category-real_time tag-cuda tag-linear-system-solving tag-lu-matrix-decomposition tag-lu-matrix-factorisation tag-parallel tag-parallelism">

			
			<h1 class="entry-title">LU Matrix Decomposition in parallel with CUDA</h1>
							<div class="entry-meta">
					<span class="meta-prep meta-prep-author">Posted on</span> <a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/" title="6:32 am" rel="bookmark"><span class="entry-date">April 21, 2011</span></a> <span class="by-author"><span class="sep">by</span> <span class="author vcard"><a class="url fn n" href="http://blog-noctua.rhcloud.com/index.php/author/admin/" title="View all posts by fanfan" rel="author">fanfan</a></span> </span><span class="comments-link"><span class="meta-sep">|</span> <a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comments" title="Comment on LU Matrix Decomposition in parallel with CUDA">11 Comments</a></span>
									</div><!-- .entry-meta -->
			
			<div class="entry-content">
				<p>The cublasStrsm() function allow us to solve linear systems in parallel but only when triangular matrix are involved.<br>
For the general case, we need to perform a LU decomposition of the matrix beforehand.</p>For now,the Cublas library lack this feature&nbsp; but almost all the Level 3 blass functions needed for the blocked LU decomposition are already available in Cublas.<br>
The Blocked LU decomposition works like standard LU decomposition. But instead of applying the algorithm to digit, each step is performed onto block matrices.<br>
<span id="more-125"></span><br>
Then lets start with the LU decomposition of a sample matrix before introducing the Blocked LU decomposition algorithm.<p></p><span style="font-size: large; color: #ff2a00;">Standard LU decomposition :</span><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_956.5_835c7056760a8d1c76d83da364c5e584.png" style="vertical-align:-43.5px; display: inline-block ;" alt="(1)   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[}{matrix{3}{3}{1 0 0 {L21} 1 0 {L31}{L32} 1}}{]} delim {[}{matrix{3}{3}{{U11} {U12} {U13} 0 {U22} {U23} 0 0 {U33}}}{]}" title="(1)   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[}{matrix{3}{3}{1 0 0 {L21} 1 0 {L31}{L32} 1}}{]} delim {[}{matrix{3}{3}{{U11} {U12} {U13} 0 {U22} {U23} 0 0 {U33}}}{]}"><p></p>From that we can compute easily&nbsp; the first Row and the first column of L and U :<p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986_ee8ab0eb51943c3c314a6dc0943aec71.png" style="vertical-align:-14px; display: inline-block ;" alt="8=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T   doubleleftright {U11}=8" title="8=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T   doubleleftright {U11}=8"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986_6ce203fc132b6354332b4c54a68e6f08.png" style="vertical-align:-14px; display: inline-block ;" alt="2=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U12} {U22} 0}}{]}^T     doubleleftright {U12}=2" title="2=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U12} {U22} 0}}{]}^T     doubleleftright {U12}=2"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986_e24ca51a1f569ccfa8642520baca1e67.png" style="vertical-align:-14px; display: inline-block ;" alt="9=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U13} {U23} {U33}}}{]}^T    doubleleftright {U13}=9" title="9=delim {[} {matrix {1}{3}{1 0 0 }} {]} delim {[} {matrix {1}{3}{{U13} {U23} {U33}}}{]}^T    doubleleftright {U13}=9"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_981_263a99a8a898d252f587e073eef6f357.png" style="vertical-align:-19px; display: inline-block ;" alt="4=delim {[} {matrix {1}{3}{{L21} 1 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T     doubleleftright {L21}=4/{U11}   doubleleftright {L21}=1/2" title="4=delim {[} {matrix {1}{3}{{L21} 1 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T     doubleleftright {L21}=4/{U11}   doubleleftright {L21}=1/2"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_981_60809b9c3e18666e6f622b645609874f.png" style="vertical-align:-19px; display: inline-block ;" alt="6=delim {[} {matrix {1}{3}{{L31} {L32} 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T    doubleleftright {L31}=6/{U11}    doubleleftright {L31}=3/4" title="6=delim {[} {matrix {1}{3}{{L31} {L32} 0 }} {]} delim {[} {matrix {1}{3}{{U11} 0 0}}{]}^T    doubleleftright {L31}=6/{U11}    doubleleftright {L31}=3/4"><p></p>We can now rewrite (1)<p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_956.5_c43debe4adc0aad4ab0c4ffb274d2ac5.png" style="vertical-align:-43.5px; display: inline-block ;" alt="(2)   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[}{matrix{3}{3}{1 0 0 0.5 1 0 0.75 {L32} 1}}{]} delim {[}{matrix{3}{3}{ 8 2 9 0 {U22} {U23} 0 0 {U33}}}{]}" title="(2)   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[}{matrix{3}{3}{1 0 0 0.5 1 0 0.75 {L32} 1}}{]} delim {[}{matrix{3}{3}{ 8 2 9 0 {U22} {U23} 0 0 {U33}}}{]}"><p></p>if we regroup terms by block :<p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_961.5_5b18c7b11c783da5afb91656ee43c230.png" style="vertical-align:-38.5px; display: inline-block ;" alt="tabular{1101}{1101}{8 2 9 4 9 4 6 7 9}  =  tabular{1101}{1101}{1 0 0 0.5 1 0 0.75 {L32} 1}    tabular{1101}{1101}{8 2 9 0 {U22} {U23} 0 0 {U33}}" title="tabular{1101}{1101}{8 2 9 4 9 4 6 7 9}  =  tabular{1101}{1101}{1 0 0 0.5 1 0 0.75 {L32} 1}    tabular{1101}{1101}{8 2 9 0 {U22} {U23} 0 0 {U33}}"><p></p>if we name : <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_971.5_44bfb265e9b971615edf005381eec61e.png" style="vertical-align:-28.5px; display: inline-block ;" alt="{A1}= delim {[} { matrix{2}{2}{9 4 7 9} } {]}     {L1}= delim {[} { matrix{2}{2}{1 0 {L32} 1} } {]}     {U1} = delim {[} { matrix{2}{2}{{U22} {U23} 0 {U33}} } {]}" title="{A1}= delim {[} { matrix{2}{2}{9 4 7 9} } {]}     {L1}= delim {[} { matrix{2}{2}{1 0 {L32} 1} } {]}     {U1} = delim {[} { matrix{2}{2}{{U22} {U23} 0 {U33}} } {]}"><p></p>Applying the block matrix product leads to : <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986_0b44ba2fac596d326e2a510d6bd4ecbb.png" style="vertical-align:-14px; display: inline-block ;" alt="{A1}= delim {[} { matrix{1}{2}{0.5 0.75} } {]}^t delim {[} { matrix{1}{2}{2 9} } {]}+{ L1} {U1}" title="{A1}= delim {[} { matrix{1}{2}{0.5 0.75} } {]}^t delim {[} { matrix{1}{2}{2 9} } {]}+{ L1} {U1}"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986_b8df7334d2b19a88d32c41eaf02ff583.png" style="vertical-align:-14px; display: inline-block ;" alt="doubleleftright {L1}{U1} = A1 - delim {[} { matrix{1}{2}{0.5 0.75 } } {]}^t delim {[} { matrix{1}{2}{2 9} } {]}" title="doubleleftright {L1}{U1} = A1 - delim {[} { matrix{1}{2}{0.5 0.75 } } {]}^t delim {[} { matrix{1}{2}{2 9} } {]}"><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_971.5_c9cddea68ce8f4b29fe959b590c6cac7.png" style="vertical-align:-28.5px; display: inline-block ;" alt="doubleleftright {L1}{U1} = delim {[} { matrix{2}{2}{ 8 -0.5 5.5 2.25} } {]}" title="doubleleftright {L1}{U1} = delim {[} { matrix{2}{2}{ 8 -0.5 5.5 2.25} } {]}"><p></p>Then, to compute <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_fe757ab99d5a621d16d7caa370e040f5.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{L1}{U1}" title="{L1}{U1}">, we can Apply&nbsp; the same steps&nbsp; to <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_971.5_8a99632de6607229e6279b20e735515c.png" style="vertical-align:-28.5px; display: inline-block ;" alt="delim {[} { matrix{2}{2}{ 8 -0.5 5.5 2.25} } {]}" title="delim {[} { matrix{2}{2}{ 8 -0.5 5.5 2.25} } {]}">.<p></p>If we repeat the process until <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_5c4128c15416562b3f2c29c4da42276e.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{Ln}{Un} " title="{Ln}{Un} "> is size <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_ffebef795df883b74eeca0a8d85e7464.png" style="vertical-align:-7.5px; display: inline-block ;" alt="1*1" title="1*1">. We get the LU decomposition of A<p></p>Finally : <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_956.5_18fbf90fb1ba4a3ae76692d8bb5817d3.png" style="vertical-align:-43.5px; display: inline-block ;" alt="   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[} { matrix{3}{3}{ 1 0 0 0.5 1 0 0.75 0.6875 1 }} {]} delim {[}{matrix{3}{3}{ 8 2 9 0 8 {-0.5} 0 0 2.59375  }}{]}" title="   delim {[} {matrix{3}{3}{8 2 9 4 9 4 6 7 9}} {]} = delim {[} { matrix{3}{3}{ 1 0 0 0.5 1 0 0.75 0.6875 1 }} {]} delim {[}{matrix{3}{3}{ 8 2 9 0 8 {-0.5} 0 0 2.59375  }}{]}"><p></p>I deliberately use a sample where we never need to divide by 0 (<img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_994.5_dbf3fd5cf5927eb958e95efe88cfdc9b.png" style="vertical-align:-5.5px; display: inline-block ;" alt="  {Aii}!=0   forall  i  " title="  {Aii}!=0   forall  i  ">). If it’s not the case a permutation matrix must be introduced to keep track of row pivoting.<p></p><span style="font-size: large; color: #ff2a00;">Block LU decomposition :</span><br>
Block LU decomposition is very similar to the algorithm we just described. The only difference is that we introduce the Block matrix at the beginning of the process.<p></p>We choose a sub matrix block size : <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_003a63aa0b2e193ef81111bc8c0b56c3.png" style="vertical-align:-7.5px; display: inline-block ;" alt="r" title="r"> and rewrite the matrix A of size <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_65c33a56f1357175c39102cc52d253b6.png" style="vertical-align:-7.5px; display: inline-block ;" alt="M*N" title="M*N"> as a block matrix:<p></p><a href="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/img46.gif"><img class="alignnone size-full wp-image-202" title="img46" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/img46.gif" alt="" width="658" height="188"></a><p></p>Where <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_5a2dd2e01d4f1e9259b400b7f596f70c.png" style="vertical-align:-7.5px; display: inline-block ;" alt="A00" title="A00"> is <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_b14640fe6e4ebd8a8c372f65eabdb669.png" style="vertical-align:-7.5px; display: inline-block ;" alt="r*r" title="r*r">.<p></p>Like we did in the LU Decomposition section we can easily compute the first row and the first column of the L and U block matrices and apply the process iteratively to <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_102b54e10ff59bf32d71d2916ed6973b.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{L11}{U11}" title="{L11}{U11}"><p></p>As the usual rules of matrix <em>multiplication</em> hold with <em>block matrices we can write</em><p></p><img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_926.5_1c9e725e9c54f0a3964eb7f404be28b6.png" style="vertical-align:-73.5px; display: inline-block ;" alt="delim{lbrace}{matrix{4}{2}{1 {{A00} = {L00}{U00}} 2 {{A10} = {L10}{U00}} 3 {{A01} = {L00}{U01}} 4 {{A11} = {L10}{U01} + {L11}{U11}}}} { }" title="delim{lbrace}{matrix{4}{2}{1 {{A00} = {L00}{U00}} 2 {{A10} = {L10}{U00}} 3 {{A01} = {L00}{U01}} 4 {{A11} = {L10}{U01} + {L11}{U11}}}} { }"><p></p>From Eq(1) and (2) We can get <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_ad721a35d138e11e856bd017df604a83.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{L00}, {U00}, {L10}" title="{L00}, {U00}, {L10}"> applying LU decomposition (cf prev section) to the matrix&nbsp; of size <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_eb971e071b9b6a5e74212ff658c65e04.png" style="vertical-align:-7.5px; display: inline-block ;" alt="M*r" title="M*r"> composed by&nbsp; <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_758ef66cc600a09340514698101aa85b.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{A00}" title="{A00}"> and <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_2ad8c8df67893f692d9c91cdc350fcfa.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{A10}" title="{A10}">.<p></p>From Eq(3) we get <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992_2a747c5771878e3d53773918a62135df.png" style="vertical-align:-8px; display: inline-block ;" alt="{U01} = {L00}^-1{A01}" title="{U01} = {L00}^-1{A01}"><p></p>Finally we rearrange Eq(4) as <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_8f23ebbb7f1e95f8ac4d4cd391360278.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{A11}prime = {A11}-{L10}{U01} = {L11}{U11}" title="{A11}prime = {A11}-{L10}{U01} = {L11}{U11}"><p></p>From this equation we see that the problem of finding&nbsp;<img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_364727cf4ba946638565049a0a4c33fd.png" style="vertical-align:-7.5px; display: inline-block ;" alt="L11" title="L11">&nbsp; and <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_40e7e84252705a7095ec16165744c843.png" style="vertical-align:-7.5px; display: inline-block ;" alt="U11" title="U11"> reduces to finding the LU factorization of the <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_986.5_09c5438de4ef8eb879b6168bb9befc77.png" style="vertical-align:-13.5px; display: inline-block ;" alt="(M-r)*(N-R)" title="(M-r)*(N-R)"> matrix <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_59508ae70f3f5cd41f9f3c9ce3113753.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{A11}prime" title="{A11}prime">. This can be done by applying the steps outlined above to <img src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/math_992.5_59508ae70f3f5cd41f9f3c9ce3113753.png" style="vertical-align:-7.5px; display: inline-block ;" alt="{A11}prime" title="{A11}prime"> instead of to <em>A</em><p></p>For an in-place algorithm, <em>A</em> is overwritten by <em>L</em> and <em>U</em> – the 1s on the diagonal of <em>L</em> do not need to be stored explicitly. Similarly, when <em>A</em> is updated by Eq.&nbsp;(5) this may also be done in place. After <em>k</em> of these <em>K</em> steps, the first <em>kr</em> columns of <em>L</em> and the first <em>kr</em> rows of <em>U</em> have been evaluated, and matrix <em>A</em> has been updated to the form shown bellow.<p></p><a href="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/img60.gif"><img title="img60" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/img60.gif" alt="" width="507" height="207"></a><p></p><span style="font-size: large; color: #ff2a00;">Implementation :</span><p></p>As stressed in the previous section, we first need to implement the standard LU decomposition.<p></p>
<div class="dp-highlighter"><div class="bar"><div class="tools"><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy to clipboard</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//***************************************************************************************</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//void&nbsp;DecomposeLU(&nbsp;int&nbsp;M,&nbsp;int&nbsp;N,&nbsp;int&nbsp;lda&nbsp;,&nbsp;float*&nbsp;A,</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int*&nbsp;permute,&nbsp;float&nbsp;epsilon,&nbsp;InfoStat&amp;&nbsp;stat)</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Num&nbsp;of&nbsp;rows&nbsp;of&nbsp;A</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Num&nbsp;of&nbsp;column&nbsp;of&nbsp;A</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Float&nbsp;Matrix&nbsp;of&nbsp;size&nbsp;M*N</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;the&nbsp;output&nbsp;contains&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;LU&nbsp;decomposition</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;diagonal&nbsp;elements&nbsp;for&nbsp;L&nbsp;are&nbsp;not&nbsp;stored&nbsp;in&nbsp;A&nbsp;(&nbsp;assuming&nbsp;they&nbsp;are&nbsp;all&nbsp;1)</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;Leading&nbsp;dim&nbsp;of&nbsp;A&nbsp;lda&nbsp;&lt;&nbsp;std::max(1,M)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Permutation&nbsp;vector&nbsp;of&nbsp;size&nbsp;M</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//epsilon&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Epsilon&nbsp;(used&nbsp;to&nbsp;test&nbsp;for&nbsp;singularities)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return&nbsp;status</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;**************************************************************************************</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;DecomposeLU(</span><span class="datatypes">int</span><span>&nbsp;M,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;N,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;lda&nbsp;,&nbsp;</span><span class="datatypes">float</span><span>*&nbsp;A,&nbsp;</span><span class="datatypes">int</span><span>*&nbsp;P,&nbsp;</span><span class="datatypes">float</span><span>&nbsp;epsilon,&nbsp;InfoStat&amp;&nbsp;stat)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasStatus&nbsp;cuStat;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Preconditions</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(&nbsp;M&lt;=0&nbsp;||&nbsp;N&lt;=0&nbsp;||&nbsp;lda&nbsp;&lt;&nbsp;std::max(1,M)&nbsp;)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._info&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(M&lt;=0)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"M&lt;=0"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(N&lt;=0)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"M&lt;=0"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(lda&nbsp;&lt;&nbsp;std::max(1,M))&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"lda&nbsp;&lt;&nbsp;std::max(1,M)"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;minDim&nbsp;=&nbsp;std::min(&nbsp;M,&nbsp;N&nbsp;);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;k=0;&nbsp;k&lt;minDim-1;&nbsp;k++)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;pivotRow&nbsp;=&nbsp;k-1+cublasIsamax(M-k,A+k&nbsp;+&nbsp;k*lda,&nbsp;1);&nbsp;</span><span class="comment">//&nbsp;row&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;submatrix</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;kp1&nbsp;=&nbsp;k+1;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P[k]&nbsp;=&nbsp;pivotRow;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(pivotRow!=k)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSswap(N,&nbsp;A+pivotRow,&nbsp;lda,&nbsp;A+k,&nbsp;lda);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">float</span><span>&nbsp;valcheck;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasGetVector(1,<span class="keyword">sizeof</span><span>(</span><span class="datatypes">float</span><span>),A+k+&nbsp;k*lda,&nbsp;1,&nbsp;&amp;valcheck,&nbsp;1);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(fabs(valcheck)&nbsp;&lt;&nbsp;epsilon)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._info&nbsp;=k+1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"&nbsp;Matrix&nbsp;is&nbsp;Singular&nbsp;"</span><span>;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(kp1&nbsp;&lt;&nbsp;M)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSscal(M-kp1,&nbsp;1.0f/valcheck,A+kp1+&nbsp;k*lda,&nbsp;1);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(&nbsp;kp1&nbsp;&lt;&nbsp;minDim&nbsp;)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSger&nbsp;(M-kp1,&nbsp;N-kp1,&nbsp;-1.0f,A+kp1+&nbsp;k*lda,&nbsp;1,&nbsp;A+k+&nbsp;kp1*lda,&nbsp;lda,A+&nbsp;kp1*lda+kp1,&nbsp;lda);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_CUBLAS(<span class="string">"decomposeLU&nbsp;pb"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="cpp" style="display: none;">//***************************************************************************************
//void DecomposeLU( int M, int N, int lda , float* A,
//&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int* permute, float epsilon, InfoStat&amp; stat)
//
// M &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : &nbsp;&nbsp;&nbsp; Num of rows of A
// N &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : &nbsp;&nbsp;&nbsp; Num of column of A
// A &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : &nbsp;&nbsp;&nbsp; Float Matrix of size M*N
//&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; on the output contains the result of the LU decomposition
//&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; The diagonal elements for L are not stored in A ( assuming they are all 1)
//lda&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; Leading dim of A lda &lt; std::max(1,M)
//P &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; :&nbsp; &nbsp;&nbsp;&nbsp; Permutation vector of size M
//epsilon&nbsp;&nbsp;&nbsp; : &nbsp;&nbsp;&nbsp; Epsilon (used to test for singularities)
//stat &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; return status
// **************************************************************************************
void DecomposeLU(int M, int N, int lda , float* A, int* P, float epsilon, InfoStat&amp; stat)
{
     cublasStatus cuStat;
     //Preconditions
     if ( M&lt;=0 || N&lt;=0 || lda &lt; std::max(1,M) )
     {
          stat._info = -1;
          if (M&lt;=0)
              stat._str = "M&lt;=0";
          if (N&lt;=0)
              stat._str = "M&lt;=0";
          if (lda &lt; std::max(1,M))
              stat._str = "lda &lt; std::max(1,M)";
          return;
     }
     int minDim = std::min( M, N );
     for (int k=0; k&lt;minDim-1; k++)
     {
          int pivotRow = k-1+cublasIsamax(M-k,A+k + k*lda, 1); // row relative to the current submatrix
          int kp1 = k+1;
          P[k] = pivotRow;
          if (pivotRow!=k)
          {
               cublasSswap(N, A+pivotRow, lda, A+k, lda);
          }
          float valcheck;
          cublasGetVector(1,sizeof(float),A+k+ k*lda, 1, &amp;valcheck, 1);
          if (fabs(valcheck) &lt; epsilon)
          {
               stat._info =k+1;
               stat._str = " Matrix is Singular ";
               return;
          }
          if (kp1 &lt; M)
         {
              cublasSscal(M-kp1, 1.0f/valcheck,A+kp1+ k*lda, 1);
         }
         if ( kp1 &lt; minDim )
         {
              cublasSger (M-kp1, N-kp1, -1.0f,A+kp1+ k*lda, 1, A+k+ kp1*lda, lda,A+ kp1*lda+kp1, lda);
         }
     }
     CHECK_CUBLAS("decomposeLU pb");
}</pre><p>As a further improvement, it would be nice to avoid the cublasGetVector() call. One solution would be to write this function as a kernel instead of using Cublas. Any other idea is welcome !</p>We can now use DecomposeLU() while performing the block decomposition :<p></p>
<div class="dp-highlighter"><div class="bar"><div class="tools"><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;ViewSource&#39;,this);return false;">view plain</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;CopyToClipboard&#39;,this);return false;">copy to clipboard</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;PrintSource&#39;,this);return false;">print</a><a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#" onclick="dp.sh.Toolbar.Command(&#39;About&#39;,this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="comment">//***************************************************************************************</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//void&nbsp;DecomposeBlockedLU&nbsp;(&nbsp;int&nbsp;M,&nbsp;int&nbsp;N,int&nbsp;lda,</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;*A,</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int*&nbsp;P,&nbsp;int&nbsp;blockSize,float&nbsp;epsilon,&nbsp;InfoStat&nbsp;&amp;stat&nbsp;)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Num&nbsp;of&nbsp;rows&nbsp;of&nbsp;A</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Num&nbsp;of&nbsp;column&nbsp;of&nbsp;A</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Float&nbsp;Matrix&nbsp;of&nbsp;size&nbsp;M*N</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;the&nbsp;output&nbsp;contains&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;LU&nbsp;decomposition</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;diagonal&nbsp;elements&nbsp;for&nbsp;L&nbsp;are&nbsp;not&nbsp;stored&nbsp;in&nbsp;A&nbsp;(&nbsp;assuming&nbsp;they&nbsp;are&nbsp;all&nbsp;1)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Leading&nbsp;dim&nbsp;of&nbsp;A&nbsp;lda&nbsp;&lt;&nbsp;std::max(1,M)&nbsp;//P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Permutation&nbsp;vector&nbsp;of&nbsp;size&nbsp;M&nbsp;//blockSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Size&nbsp;of&nbsp;the&nbsp;submatrices&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;blockSize&gt;=M&nbsp;||&nbsp;blockSize==1&nbsp;unblocked&nbsp;decomposition&nbsp;is&nbsp;called</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//epsilon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;Epsilon&nbsp;(used&nbsp;to&nbsp;test&nbsp;for&nbsp;singularities)</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="comment">//stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return&nbsp;status</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="comment">//&nbsp;**************************************************************************************</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">void</span><span>&nbsp;DecomposeBlockedLU&nbsp;(&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;M,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;N,</span><span class="datatypes">int</span><span>&nbsp;lda,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">float</span><span>&nbsp;*A,&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>*&nbsp;P,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;blockSize,</span><span class="datatypes">float</span><span>&nbsp;epsilon,&nbsp;InfoStat&nbsp;&amp;stat&nbsp;)&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;cublasStatus&nbsp;cuStat;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Preconditions</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(M&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;N&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;lda&nbsp;&lt;&nbsp;std::max(1,M)&nbsp;)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._info&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(M&lt;=0)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"M&lt;=0"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(N&lt;=0)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"M&lt;=0"</span><span>;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(lda&nbsp;&lt;&nbsp;std::max(1,M))&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stat._str&nbsp;=&nbsp;<span class="string">"lda&nbsp;&lt;&nbsp;std::max(1,M)"</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;minSize&nbsp;=&nbsp;std::min(M,N);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(&nbsp;blockSize&nbsp;&gt;&nbsp;minSize&nbsp;||&nbsp;blockSize&nbsp;==&nbsp;1)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//straight&nbsp;LU&nbsp;decomposition</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DecomposeLU(&nbsp;M,&nbsp;N,&nbsp;lda,&nbsp;A,&nbsp;P,&nbsp;epsilon,&nbsp;stat);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//blocked&nbsp;decomposition</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=0;&nbsp;i&lt;&nbsp;minSize&nbsp;;&nbsp;i+=blockSize)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;realBlockSize&nbsp;&nbsp;=&nbsp;std::min(minSize&nbsp;-&nbsp;i,&nbsp;blockSize);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//decompose&nbsp;the&nbsp;current&nbsp;rectangular&nbsp;block</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DecomposeLU(&nbsp;M-i,&nbsp;realBlockSize,&nbsp;lda,&nbsp;A+i+i*lda,&nbsp;P+i,&nbsp;epsilon,&nbsp;stat);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//adjust&nbsp;pivot&nbsp;infos</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Todo&nbsp;:&nbsp;write&nbsp;a&nbsp;kernel&nbsp;for&nbsp;that</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;p&nbsp;=&nbsp;i;&nbsp;p&lt;&nbsp;std::min(&nbsp;M,&nbsp;i+realBlockSize)-1;&nbsp;p++)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P[p]&nbsp;=&nbsp;P[p]+i;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(P[p]&nbsp;!=&nbsp;p)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Apply&nbsp;interchanges&nbsp;to&nbsp;columns&nbsp;0:i.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSswap(i,&nbsp;A+p&nbsp;,&nbsp;lda,&nbsp;A+&nbsp;P[p],&nbsp;lda);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Apply&nbsp;interchanges&nbsp;to&nbsp;columns&nbsp;i+blockSize:N.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSswap(N-i-realBlockSize,&nbsp;A+p+(i+realBlockSize)*lda&nbsp;,&nbsp;lda,&nbsp;A+&nbsp;P[p]+(i+realBlockSize)*lda,&nbsp;lda);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Compute&nbsp;block&nbsp;row&nbsp;of&nbsp;U.</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasStrsm(&nbsp;<span class="string">'l'</span><span>,</span><span class="string">'l'</span><span>,</span><span class="string">'n'</span><span>,</span><span class="string">'u'</span><span>,&nbsp;realBlockSize,&nbsp;N-i-realBlockSize,&nbsp;1.0f,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;+i&nbsp;+i*lda,&nbsp;lda,&nbsp;A&nbsp;+i&nbsp;+&nbsp;(i+realBlockSize)*lda,&nbsp;lda);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_CUBLAS(<span class="string">"decomposeBlockedLU&nbsp;cublasStrsm"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(i+realBlockSize&nbsp;&lt;&nbsp;M)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cublasSgemm(<span class="string">'n'</span><span>,</span><span class="string">'n'</span><span>,&nbsp;&nbsp;M-i-realBlockSize,&nbsp;N-i-realBlockSize,&nbsp;realBlockSize,&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0f,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A+i+realBlockSize+i*lda,lda,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A+i+(realBlockSize+i)*lda,lda,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0f,&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A+i+realBlockSize+(realBlockSize+i)*lda,lda&nbsp;);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHECK_CUBLAS(<span class="string">"decomposeBlockedLU&nbsp;cublasSgemm"</span><span>);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="cpp" style="display: none;">//***************************************************************************************
//void DecomposeBlockedLU (	int M, int N,int lda,
//							float *A,
//							int* P, int blockSize,float epsilon, InfoStat &amp;stat )
//
// M 			: 	Num of rows of A
// N 			: 	Num of column of A
// A 			: 	Float Matrix of size M*N
//					on the output contains the result of the LU decomposition
//					The diagonal elements for L are not stored in A ( assuming they are all 1)
//lda			:	Leading dim of A lda &lt; std::max(1,M) //P 			:  	Permutation vector of size M //blockSize		:	Size of the submatrices //					if blockSize&gt;=M || blockSize==1 unblocked decomposition is called
//epsilon		: 	Epsilon (used to test for singularities)
//stat 	 		:  return status
// **************************************************************************************
void DecomposeBlockedLU (	int M, int N,int lda,
							float *A,
							int* P, int blockSize,float epsilon, InfoStat &amp;stat )
{

	cublasStatus cuStat;
	//Preconditions
	if (M &lt; 0 || N &lt; 0 || lda &lt; std::max(1,M) )
	{
		stat._info = -1;
		if (M&lt;=0)
			stat._str = "M&lt;=0";
		if (N&lt;=0)
			stat._str = "M&lt;=0";
		if (lda &lt; std::max(1,M))
			stat._str = "lda &lt; std::max(1,M)"; 		return; 	} 	int minSize = std::min(M,N); 	if ( blockSize &gt; minSize || blockSize == 1)
	{
		//straight LU decomposition
		DecomposeLU( M, N, lda, A, P, epsilon, stat);
	}
	else
	{
		//blocked decomposition
		for (int i =0; i&lt; minSize ; i+=blockSize)
		{
			int realBlockSize  = std::min(minSize - i, blockSize);

			//decompose the current rectangular block
			DecomposeLU( M-i, realBlockSize, lda, A+i+i*lda, P+i, epsilon, stat);

			//adjust pivot infos
			//Todo : write a kernel for that
			for (int p = i; p&lt; std::min( M, i+realBlockSize)-1; p++)
			{
					P[p] = P[p]+i;
					if (P[p] != p)
					{
						// Apply interchanges to columns 0:i.
						cublasSswap(i, A+p , lda, A+ P[p], lda);
						// Apply interchanges to columns i+blockSize:N.
						cublasSswap(N-i-realBlockSize, A+p+(i+realBlockSize)*lda , lda, A+ P[p]+(i+realBlockSize)*lda, lda);
					}

			}

			// Compute block row of U.
			cublasStrsm( 'l','l','n','u', realBlockSize, N-i-realBlockSize, 1.0f,
						 A +i +i*lda, lda, A +i + (i+realBlockSize)*lda, lda);
			CHECK_CUBLAS("decomposeBlockedLU cublasStrsm");

			if (i+realBlockSize &lt; M)
			{
				 cublasSgemm('n','n',  M-i-realBlockSize, N-i-realBlockSize, realBlockSize,
							 -1.0f,
							 A+i+realBlockSize+i*lda,lda,
							 A+i+(realBlockSize+i)*lda,lda,
							 1.0f,
							 A+i+realBlockSize+(realBlockSize+i)*lda,lda );
				 CHECK_CUBLAS("decomposeBlockedLU cublasSgemm");
			}
		}
	}

}</pre><p><span style="font-size: large; color: #ff2a00;">Performances improvement :</span></p>For a random 10 000*10 000 matrix DecomposeBlockedLU run in about 3 second on my Quadro FX 4800 versus 98 second if we use DecomposeLU alone.<p></p>This code is used as a basis for Radial Basis Function interpolation computed on the GPU. I’m still eager to get better performances. I’m considering writing some part of it as a Cuda kernel. For any suggestion or if you know any alternative implementation available, thanks to drop me a mail or a comment.<p></p>
							</div><!-- .entry-content -->

			<div class="entry-info">
							This entry was posted in <a href="http://blog-noctua.rhcloud.com/index.php/category/programming/real_time/" rel="category tag">Real time</a> and tagged <a href="http://blog-noctua.rhcloud.com/index.php/tag/cuda/" rel="tag">cuda</a>, <a href="http://blog-noctua.rhcloud.com/index.php/tag/linear-system-solving/" rel="tag">linear system solving</a>, <a href="http://blog-noctua.rhcloud.com/index.php/tag/lu-matrix-decomposition/" rel="tag">LU Matrix Decomposition</a>, <a href="http://blog-noctua.rhcloud.com/index.php/tag/lu-matrix-factorisation/" rel="tag">LU matrix factorisation</a>, <a href="http://blog-noctua.rhcloud.com/index.php/tag/parallel/" rel="tag">parallel</a>, <a href="http://blog-noctua.rhcloud.com/index.php/tag/parallelism/" rel="tag">parallelism</a>. Bookmark the <a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/" title="Permalink to LU Matrix Decomposition in parallel with CUDA" rel="bookmark">permalink</a>.							</div><!-- .entry-info -->
		</div><!-- #post-## -->

		<div id="nav-below" class="navigation">
			<div class="nav-previous"><a href="http://blog-noctua.rhcloud.com/index.php/2010/04/25/beauty-of-nature/" rel="prev"><span class="meta-nav">←</span> Beauty of nature</a></div>
			<div class="nav-next"><a href="http://blog-noctua.rhcloud.com/index.php/2011/05/31/linux-memo/" rel="next">Linux memo <span class="meta-nav">→</span></a></div>
		</div><!-- #nav-below -->

		
<div id="comments">

	
			<h3 id="comments-title">
			11 responses to “<span>LU Matrix Decomposition in parallel with CUDA</span>”		</h3>

		
		<ol class="commentlist">
				<li class="comment even thread-even depth-1" id="li-comment-356">
		<div id="comment-356">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/fb0fd07485efdfc05e02987075fdbab0" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">Sylvestre</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-356">
				June 6, 2011 at 11:59 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=356#respond" onclick="return addComment.moveForm( &quot;comment-356&quot;, &quot;356&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to Sylvestre">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hello,</p>
<p>Thanks for this code.<br>
Under which license is it released ?</p>
<p>thanks<br>
S</p>
</div>

	</div><!-- #comment-##  -->

	<ul class="children">
	<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-357">
		<div id="comment-357">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/8bf195b664b95b5fb30e0bb775672c5f" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">fanfan</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-357">
				June 7, 2011 at 6:16 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=357#respond" onclick="return addComment.moveForm( &quot;comment-357&quot;, &quot;357&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to fanfan">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hi Sylvestre<br>
This code is released under BSD license.<br>
Cheers.</p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	<li class="comment even thread-odd thread-alt depth-1" id="li-comment-358">
		<div id="comment-358">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/f0f8240e0259c4ae8264baf7e282d1f6" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">andrea chiariello</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-358">
				June 27, 2011 at 5:42 pm</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=358#respond" onclick="return addComment.moveForm( &quot;comment-358&quot;, &quot;358&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to andrea chiariello">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hello,<br>
I need to use a function like this in order to solve a linear system problem with matrix dimension that don’t fill in the device memory.</p>
<p>Do you think that are possible use the same approach to do this task?</p>
<p>Have you some suggestions for me?</p>
<p>Thank a lot in advance for your help<br>
Best regards<br>
Andrea</p>
</div>

	</div><!-- #comment-##  -->

	<ul class="children">
	<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-359">
		<div id="comment-359">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/8bf195b664b95b5fb30e0bb775672c5f" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">fanfan</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-359">
				June 28, 2011 at 12:54 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=359#respond" onclick="return addComment.moveForm( &quot;comment-359&quot;, &quot;359&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to fanfan">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hi Andrea,</p>
<p>Yes, I think it would not be too difficult to adapt the code to an hybrid GPU/CPU solution.<br>
Start  with a CPU Blocked LU (choosing a block size that fills in the Device memory) then solve each block using the GPU  blocked LU as shown in this post.<br>
You can implement a  CPU Blocked LU implementation   using <a href="http://www.netlib.org/lapack/" rel="nofollow">LAPACK</a> .<br>
For this implementation, instead of calling DecomposeLU()  the CPU Blocked LU will call  the GPU blocked LU.<br>
Cheers,</p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="li-comment-361">
		<div id="comment-361">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/d9856b43f7635c6f1c4ec39cf9660e75" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">Clément Canonne</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-361">
				July 22, 2011 at 2:02 pm</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=361#respond" onclick="return addComment.moveForm( &quot;comment-361&quot;, &quot;361&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to Clément Canonne">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hi,</p>
<p>First, thanks for your article – it’s really clear and helpful.<br>
I think i’ve found a small mistake in the code, though : in DecomposeBlockedLU(), line 67, shouldn’t  the first dimension argument be “M-i-realBlockSize” (and not “N-i-realBlockSize” which appears twice) ?</p>
<p># cublasSgemm(‘n’,’n’,  M-i-realBlockSize, N-i-realBlockSize, realBlockSize, </p>
<p>Best regards,</p>
<p>Clément</p>
</div>

	</div><!-- #comment-##  -->

	<ul class="children">
	<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-362">
		<div id="comment-362">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/8bf195b664b95b5fb30e0bb775672c5f" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">fanfan</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-362">
				July 22, 2011 at 3:04 pm</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=362#respond" onclick="return addComment.moveForm( &quot;comment-362&quot;, &quot;362&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to fanfan">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hi Clement,</p>
<p>Thanks for your feedback.<br>
You are perfectly  right, it is  # cublasSgemm(‘n’,’n’, M-i-realBlockSize, N-i-realBlockSize, realBlockSize<br>
I updated the article.<br>
Cheers.<br>
F.</p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	<li class="comment even thread-odd thread-alt depth-1" id="li-comment-363">
		<div id="comment-363">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/d9856b43f7635c6f1c4ec39cf9660e75" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">Clément Canonne</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-363">
				July 26, 2011 at 11:38 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=363#respond" onclick="return addComment.moveForm( &quot;comment-363&quot;, &quot;363&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to Clément Canonne">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>Hi,<br>
another small question about the pivoting: in the code, it doesn’t seem to me that P[minDim] is ever set – is that normal?</p>
</div>

	</div><!-- #comment-##  -->

	<ul class="children">
	<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-364">
		<div id="comment-364">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/8bf195b664b95b5fb30e0bb775672c5f" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">fanfan</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-364">
				July 26, 2011 at 1:16 pm</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=364#respond" onclick="return addComment.moveForm( &quot;comment-364&quot;, &quot;364&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to fanfan">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>It’s up to the client code to initialize the vector with a sequence (0,1,2 … ,M-1) </p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	<li class="comment even thread-even depth-1" id="li-comment-365">
		<div id="comment-365">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/d9856b43f7635c6f1c4ec39cf9660e75" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">Clément Canonne</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-365">
				July 26, 2011 at 2:21 pm</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=365#respond" onclick="return addComment.moveForm( &quot;comment-365&quot;, &quot;365&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to Clément Canonne">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>OK. Anyway, unless i’m mistaken, using the resulting P as a permutation matrix does not require to ever consider the last component (swapping iteratively the rows, starting at 0 and to M-2, should put the M rows to their “correct” position) – or am i mistaken?</p>
</div>

	</div><!-- #comment-##  -->

	<ul class="children">
	<li class="comment byuser comment-author-admin bypostauthor odd alt depth-2" id="li-comment-366">
		<div id="comment-366">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/8bf195b664b95b5fb30e0bb775672c5f" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">fanfan</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-366">
				July 27, 2011 at 5:30 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=366#respond" onclick="return addComment.moveForm( &quot;comment-366&quot;, &quot;366&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to fanfan">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>It sounds good,  if B is a “colum” device vector of size M, you can do :<br>
for (int i=0;i&lt;M-1;i++)<br>
      if(i != P[i] )  cublasSswap(1,B+i,1,B+P[i],1);</p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	<li class="comment even thread-odd thread-alt depth-1" id="li-comment-384">
		<div id="comment-384">
		<div class="comment-author vcard">
			<img alt="" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/54d84ab0ab995dd1ac9934e038c57f1d" class="avatar avatar-48 photo" height="48" width="48">
			<cite class="fn">Stuttgart Webdesign</cite>

			<span class="comment-meta commentmetadata">
				|
				<a href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/#comment-384">
				November 16, 2011 at 7:01 am</a>
					|
					<a class="comment-reply-link" href="http://blog-noctua.rhcloud.com/index.php/2011/04/21/lu-matrix-decomposition-in-parallel-with-cuda/?replytocom=384#respond" onclick="return addComment.moveForm( &quot;comment-384&quot;, &quot;384&quot;, &quot;respond&quot;, &quot;125&quot; )" aria-label="Reply to Stuttgart Webdesign">Reply</a>								</span><!-- .comment-meta .commentmetadata -->
		</div><!-- .comment-author .vcard -->
		
		<div class="comment-body"><p>I discovered your blog site on google and check a few of your early posts. Continue to keep up the very good operate. Seeking forward to reading more from you later…</p>
</div>

	</div><!-- #comment-##  -->

	</li><!-- #comment-## -->
		</ol>
</div><!-- #comments -->
	
	</div><!-- #content -->
</div><!-- #content-container -->


		
		<div id="primary" class="widget-area" role="complementary">
					<ul class="xoxo">

			<li id="categories-203808961" class="widget-container widget_categories"><h3 class="widget-title">Categories</h3>		<ul>
	<li class="cat-item cat-item-10"><a href="http://blog-noctua.rhcloud.com/index.php/category/programming/maya_tools/">Maya tools</a>
</li>
	<li class="cat-item cat-item-13"><a href="http://blog-noctua.rhcloud.com/index.php/category/programming/">Programming</a>
</li>
	<li class="cat-item cat-item-11"><a href="http://blog-noctua.rhcloud.com/index.php/category/programming/real_time/">Real time</a>
</li>
	<li class="cat-item cat-item-1"><a href="http://blog-noctua.rhcloud.com/index.php/category/uncategorized/">Uncategorized</a>
</li>
	<li class="cat-item cat-item-65"><a href="http://blog-noctua.rhcloud.com/index.php/category/visual-art/">Visual Art</a>
</li>
	<li class="cat-item cat-item-29"><a href="http://blog-noctua.rhcloud.com/index.php/category/work/">Work</a>
</li>
		</ul>
</li><li id="pages-2" class="widget-container widget_pages"><h3 class="widget-title">Contact</h3>		<ul>
			<li class="page_item page-item-2"><a href="http://blog-noctua.rhcloud.com/index.php/about/">About</a></li>
<li class="page_item page-item-92"><a href="http://blog-noctua.rhcloud.com/index.php/contact/">Contact</a></li>
<li class="page_item page-item-341"><a href="http://blog-noctua.rhcloud.com/index.php/resume/">Resume</a></li>
		</ul>
		</li>			</ul>
		</div><!-- #primary .widget-area -->

		
			</div><!-- #content-box -->

	<div id="footer" role="contentinfo">
		
		<div id="colophon">
			<span class="generator-link"><a href="http://wordpress.org/" title="A Semantic Personal Publishing Platform" rel="generator">Proudly powered by WordPress.</a></span>
			Theme: Coraline by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- #colophon -->
	</div><!-- #footer -->

</div><!-- #container -->

<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shCore.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushCSharp.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushPhp.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushJScript.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushJava.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushVb.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushSql.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushXml.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushDelphi.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushPython.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushRuby.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushCss.js"></script>
<script class="javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/shBrushCpp.js"></script>
<script class="javascript">
dp.SyntaxHighlighter.ClipboardSwf = 'http://blog-noctua.rhcloud.com/wp-content/plugins/google-syntax-highlighter/Scripts/clipboard.swf';
dp.SyntaxHighlighter.HighlightAll('code');
</script><style>.dp-cpp .datatypes { color: #2E8B57; font-weight: bold; }</style><style>.dp-cpp .datatypes { color: #2E8B57; font-weight: bold; }</style>
<script type="text/javascript" src="./LU Matrix Decomposition in parallel with CUDA _ Noctua_files/comment-reply.min.js"></script>

</body></html>